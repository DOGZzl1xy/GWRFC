#'@title Clustering and statistical summaries
#'@description This function clusters table columns of a SpatialDataFrame object and reports its resulting clusters as an statistical summary. It is also capable to report a specific column but clustering is not applied and values are reported as quantiles (if numerical), or classes (if categorical).
#'@param input_shapefile string or Spatial-class. It can be a filename or an object of class {SpatialPolygonsDataFrame} or {SpatialPointsDataFrame}.
#'@param remove_columns string. Remove specific variables from \strong{input_shapefile}. Variables are identified by column name. NA ignores column remove.
#'@param clus_data string. Refers to data which should be used included for clustering. It can be "all" to use all \strong{input_shapefile} variables or any other variables specified. In all cases, it uses numeric variables except with "lucca" clustering approach. If one variable is declared, clustering is not applied and data from target variable is reported according its quantiles (when it is numerical) or its classes (when it is categorical).
#'@param method_hc string. A method to use for clustering. As hierchachical clustering is applied through {hclust} function. It can be:"ward.D","ward.D2","single","complete","average","mcquitty","median", "centroid" but other alternatives are "SOM" and "lucca" which uses kohonen and mclust packages respectively. Not relevant if \strong{clus_data} includes one variable.
#'@param clus_num numeric or string. If clustering is applied, this is the number of clusters. If it can be defined as "auto" (using Calinski-Harabasz Index) or any number greater than 2.
#'@param plots logical. If true, plots are generated and stored in the \strong{output_folder}.
#'@param scaled logical. If true, quantitative variables plots are scaled and showed as boxplots, otherwise as bars.
#'@param output_folder string. Output folder where results will be stored.
#'@return The results of the function includes: \enumerate{
#'                            \item A shapefile with the resulting clusters or classes used for report.
#'                            \item A statistical summary for each cluster or class (stored in a .rds file)
#'                            \item Plots derived from the cluster analysis.
#'                           }
#'@examples
#'#based in the example showed with the execution of GWRFC
#'list.files("E:/demo/test",full.names=T,pattern=".shp") #get the output filename from GWRFC function
#'
#'GWRFC_clus(input_shapefile = "E:/demo/test/GWRFC_ADP_400_EX_LVI.shp" , # we choose LVI output
#'          remove_columns = "ID_row",
#'          clus_data = "all" #to use all columns.
#'          method_hc="ward.D2",
#'          clus_num = "auto",
#'          plots=T,
#'          output_folder = "E:/DATA/demo/clus") #check this folder for outputs generated by the function.
#'@export

GWRFC_clus <- function(
  input_shapefile,
  remove_columns = NA,
  clus_data = "all",
  method_hc="ward.D2",
  clus_num="auto",
  plots=T,
  scaled=T,
  output_folder
){

  ##### PREPARE DATA #####

  print("Reading data...")

  #random + test
  set.seed(666)
  if(clus_num==1){
    stop("Clustering can´t be less than 2")
  }
  #output folder
  dir.create(output_folder,showWarnings = F, recursive = T)
  #read
  if(class(input_shapefile)=="SpatialPolygonsDataFrame"|class(input_shapefile)=="SpatialPointsDataFrame"){
    ini.shp <- input_shapefile
  }else{
    ini.shp <- shapefile(input_shapefile)
  }
  #remove columns?
  if(!is.na(remove_columns)[1]){
    if(length(grep(paste(remove_columns,collapse="|"),names(ini.shp))) != 0){
      ini.shp <- ini.shp[,!names(ini.shp) %in% remove_columns]
    }else{
      stop("remove_columns not found at input_shapefile. Verify its names.")
    }
  }
  #backup data
  ini.data <- ini.shp@data
  #get cluster data
  if(clus_data[1]!="all"){
    if(any(!clus_data %in% names(ini.shp@data))){
      stop("not all clus_data columns found")
    }
    ini.shp@data <- ini.shp@data[,names(ini.shp@data) %in% clus_data,drop=F]
  }
  #identify column types
  num.vars <- sapply(ini.shp@data,is.numeric)

  #### FUNCTIONS ####

  ApplyQuintiles <- function(x) {
    cut(x, breaks=c(quantile(df$orders, probs = seq(0, 1, by = 0.20))),
        labels=c("0-20","20-40","40-60","60-80","80-100"), include.lowest=TRUE)
  }

  bar.ini <- function(x){
    #plot
    p <- ggplot(x, aes(x=reorder(variable, value),y=value,
                       group=CLUSTER,
                       fill=CLUSTER)) +
      theme_bw() +
      theme(plot.title = element_text(size = 20),
            #panel
            panel.grid.major = element_line(size = 0.5, linetype = 'dotted',colour = "black"),
            #legend
            legend.title=element_text(size=15),
            legend.text=element_text(size=15),
            legend.key = element_rect(colour = "black"),
            legend.position="bottom",
            #axis x
            axis.title.x=element_text(size=15),
            axis.text.x=element_text(hjust = 1,size=15),
            #axis y
            axis.title.y=element_text(size=15),
            axis.text.y=element_text(hjust = 1,size=15),
            strip.text.y=element_text(size=15),
            #facet titles off
            strip.background = element_blank(),
            strip.text.x = element_blank(),
            #margins
            plot.margin=unit(c(0,0,0,0),"cm")) +
      #legend columns
      guides(col = guide_legend(nrow=1,byrow=T)) +
      #shapes
      geom_col(position = "dodge") +
      geom_hline(yintercept=0,linetype="dashed") +
      #other
      coord_flip() +
      facet_wrap(~CLUSTER,ncol=2) +
      labs(title="Quantitative variables, grouped by clusters",
           x="Variables",
           y="Values (check units source)")
    return(p)
  }

  boxplot.quanti <- function(x,y_range=c(-3,3)){
    p <- ggplot(x,aes(x=reorder(variable,value), y=value,
                      fill=CLUSTER,
                      group=interaction(variable,CLUSTER))) +
      theme_bw() +
      theme(plot.title = element_text(size = 20),
            #legend
            legend.title=element_text(size=15),
            legend.text=element_text(size=15),
            legend.key = element_rect(colour = "black"),
            legend.position="bottom",
            #x axis
            axis.title.x=element_text(size=15),
            axis.text.x=element_text(hjust = 1,size=15,angle=45),
            #y axis
            axis.title.y=element_text(size=15),
            axis.text.y=element_text(hjust = 1,size=15),
            strip.text.y=element_text(size=15),
            #facet titles off
            strip.background = element_blank(),
            strip.text.x = element_blank(),
            #margins
            plot.margin=unit(c(0,0,0,0),"cm")) +
      #boxplot geom
      geom_boxplot(position=position_dodge(width = 0.75),outlier.alpha=0.33,
                   show.legend = T) +
      #others
      geom_hline(yintercept=0,linetype="dotted",color="black",size=0.75) +
      coord_cartesian(ylim=y_range) +
      labs(title="Standarized values for quantitative variables, grouped by clusters",
           x="Variables (Mean ± SD)",
           y="Z-scores")
    return(p)
  }

  hist.quali <- function(x){
    p <- ggplot(x,aes(x=value,
                      fill=CLUSTER)) +
      theme_bw() +
      theme(plot.title = element_text(size = 20),
            #legend
            legend.title=element_text(size=15),
            legend.text=element_text(size=15),
            legend.key = element_rect(colour = "black"),
            legend.position="bottom",
            #x axis
            axis.title.x=element_text(size=15),
            axis.text.x=element_text(hjust = 1,size=15,angle=45),
            strip.text.x=element_text(size=15),
            #y axis
            axis.title.y=element_text(size=15),
            axis.text.y=element_text(hjust = 1,size=15),
            strip.text.y=element_text(size=15),
            #margins
            plot.margin=unit(c(0,0,0,0),"cm")) +
      #bar geom
      geom_bar(position = "dodge") +
      #other
      coord_flip() +
      facet_wrap(~variable,scales="free",ncol=4) +
      labs(title="Classes counts for qualitative variables, grouped by clusters",
           y="Count",
           x="Classes")
    return(p)
  }

  Mode <- function(x) {
    ux <- unique(x)
    ux[which.max(tabulate(match(x, ux)))]
  }

  x.summary <- function(x,fun){
    x <- x[complete.cases(x),]
    if(fun=="Mode"){
      x.agr <- stats::aggregate(x[,1:(ncol(x)-1),drop=F],
                                by = list(x$CLUSTER),
                                FUN = Mode)
    }else{
      x.agr <- stats::aggregate(x[,1:(ncol(x)-1),drop=F],
                                by = list(x$CLUSTER),
                                FUN = fun)
    }
    names(x.agr)[1] <- "CLUSTER"
    x.agr <- reshape::melt(x.agr,id.vars="CLUSTER")
    names(x.agr)[3] <- fun
    return(x.agr)
  }

  get.elbow <- function(threshold,x, y) {
    d1 <- diff(y) / diff(x) # first derivative
    d2 <- diff(d1) / diff(x[-1]) # second derivative
    indices <- which(abs(d2) > threshold)
    return(indices)
  }

  plot.SOM <- function(x){
    if(ncol(x)!=9){
      x.na <- 9-length(x)
      x.na <- lapply(x.na,function(y){
        y <- rep(NA,nrow(x))
      })
      x <- cbind(x,as.data.frame(x.na))
    }
    jpeg(output.name, width = 1000, height = 1000)
    par(mfrow=c(3,3))
    for(j in 1:9){
      if(all(is.na(x[,j]))){
        plot(0,type='n',axes=FALSE,ann=FALSE)
      }else{
        plot(som.model,
             type = "property",
             property=x[,j],
             main=names(x)[j],
        )
      }
    }
    dev.off()
  }

  report.quanti <- function(x){
    x.clus <- x$CLUSTER
    x <- x[,1:(ncol(x)-1)]
    x <- x[,sapply(x,is.numeric),drop=F]
    if(length(x)!=0){
      x$CLUSTER <- x.clus
      x.report <- x.summary(x,"mean")
      names(x.report)[3] <- "mean"
      x.report$sd <- x.summary(x,"sd")[,3]
      x.report$min <- x.summary(x,"min")[,3]
      x.report$max <- x.summary(x,"max")[,3]
      x.act <- T
    }else{
      x.report <- NA
      x.act <- F
    }
    return(list(x.report,x.act))
  }

  report.quali <- function(x){
    x.clus <- x$CLUSTER
    x <- x[,1:(ncol(x)-1)]
    x <- x[,!sapply(x,is.numeric),drop=F]
    if(length(x)!=0){
      x$CLUSTER <- x.clus
      x.report <- x.summary(x,"Mode")
      x.act <- T
    }else{
      x.report <- NA
      x.act <- F
    }
    return(list(x.report,x.act))
  }

  #### CLUSTERING ####

  print("Start clustering...")

  #start with multi-dimensional

  if(ncol(ini.shp)>=2){
    #get cluster number
    if(clus_num=="auto"){
      ini.clus <- hclust(dist(ini.shp@data[,num.vars]), method = "ward.D2")
      cal.vals <- sapply(2:20,function(x){
        calinhara(ini.shp@data[,num.vars],cutree(ini.clus, k = x))
      })
      clus_num <- get.elbow(unlist(cal.vals),1:19,0.015)[1]
      if(is.na(clus_num)){
        warning("elbow not found. Assumed 2 clusters...")
        clus_num <- 2
      }
    }

    # KOHONEN

    if(method_hc=="SOM"){

      som.data <- ini.shp@data[,num.vars]
      na.vals <- complete.cases(som.data)
      som.data <- as.matrix(scale(som.data[na.vals,]))
      som.grid <- somgrid(xdim = 5, ydim=5, topo="hexagonal")
      som.model <- som(som.data, grid = som.grid)
      som.clus <- cutree(hclust(dist(unlist(som.model$codes))),k=clus_num+1)
      if(plots){
        som.plots <- c("codes", "changes", "counts","dist.neighbours", "mapping", "quality")
        output.name <- paste0(output_folder,"/clus_",clus_num,"_SOM-quality.jpg")
        jpeg(output.name, width = 1000, height = 1000)
        par(mfrow=c(3,3))
        for(j in 1:7){
          if(j!=7){
            plot(som.model, type=som.plots[j])
          }else{
            plot(som.model,
                 type = "property",
                 property=som.clus,
                 main="clusters")
          }
        }
        dev.off()
        #plot data
        som.plots <- names(ini.shp@data[,num.vars])
        som.plots <- split(som.plots, ceiling(seq_along(som.plots)/9))
        for(j in 1:length(som.plots)){
          output.name <- paste0(output_folder,"/clus_",clus_num,"_SOM-",j,".jpg")
          if(length(som.plots[[j]])==9){
            plot.SOM(ini.shp@data[,som.plots[[j]]])
          }
        }
      }
      ini.shp@data$CLUSTER <- NA
      ini.shp@data$CLUSTER[na.vals] <- som.clus[som.model$unit.classif]

    }

    # LUCA SCTRUCCA

    if(method_hc=="lucca"){
      index.na <- complete.cases(ini.shp@data)
      ini.clus <- ini.shp@data[index.na,]
      clus.val <- Mclust(ini.clus, G=clus_num)
      clus.val <- as.character(clus.val$classification)
      ini.clus <- cbind(ini.shp@data,data.frame(CLUSTER=NA))
      ini.clus[index.na,]$CLUSTER <- clus.val
      ini.shp@data <- ini.clus

    }else{

      # HIERARCHICAL CLUSTERING

      #get clusters
      ini.clus <- hclust(dist(ini.shp@data[,num.vars]), method = method_hc)
      ini.shp@data$CLUSTER <- cutree(ini.clus, k = clus_num)
    }

  }else{

    # continue with unidimensional

    # QUANTILES

    ini.shp@data$CLUSTER <- ini.shp@data[,grep(clus_data,names(ini.shp))]
    if(is.numeric(ini.shp@data$CLUSTER)){
      breaks.val <- ini.shp@data$CLUSTER
      breaks.val <- c(-Inf,summary(breaks.val)[2],summary(breaks.val)[3],summary(breaks.val)[5],Inf)
      labels.val <- c("Q25","Q50","Q75","Q100")
      ini.shp@data$CLUSTER <- base::cut(as.numeric(ini.shp@data$CLUSTER),breaks=breaks.val,labels=labels.val)
    }else{

      # CLASSES

      ini.shp@data$CLUSTER <- ini.shp@data[,grep(clus_data,names(ini.shp))]
    }
    clus_num <- nlevels(ini.shp@data$CLUSTER)
  }

  #output clusters
  ini.shp@data <- ini.shp@data[,ncol(ini.shp),drop=F]
  output.name <- paste0(output_folder,"/clus_",clus_num,"_geom.jpg")
  shapefile(ini.shp,output.name,overwrite=T)

  #### REPORT ####

  print("Making report...")

  #get data
  ini.data$CLUSTER <- factor(ini.shp$CLUSTER)
  #summary quantitative
  quanti.report <- report.quanti(ini.data)[[1]]
  quanti.act <-  report.quanti(ini.data)[[2]]
  #summary qualitative
  quali.report <- report.quali(ini.data)[[1]]
  quali.act <-  report.quali(ini.data)[[2]]
  #plots
  if(plots){
    #quantitative plots
    if(quanti.act){
      quanti.df <- ini.data[,sapply(ini.data,is.numeric),drop=F]
      quanti.df$CLUSTER <- ini.data$CLUSTER
      #quanti.df <- quanti.df[!is.na(quanti.df$CLUSTER),]
      quanti.df <- quanti.df[complete.cases(quanti.df),]
      if(!scaled){
        quanti.plot <- reshape::melt(quanti.df,id.vars="CLUSTER")
        quanti.plot <- bar.ini(quanti.plot)
        output.name <- paste0(output_folder,"/clus_",clus_num,"_num.jpg")
        set.size <- c(nlevels(quanti.df$CLUSTER),ncol(quanti.df))
        ggsave(filename=output.name,quanti.plot,dpi = 300, width=15*set.size[1],height=1*set.size[2],units="cm",limitsize=F)
      }else{
        scale.vals <- scale(quanti.df[,1:(ncol(quanti.df)-1)])
        quanti.df[,1:(ncol(quanti.df)-1)] <- scale.vals
        scale.vals <- paste0(names(quanti.df)[1:(ncol(quanti.df)-1)],"\n","(",
                             round(attr(scale.vals,"scaled:center"),2)," ± ",
                             round(attr(scale.vals,"scaled:scale"),2),")")
        names(quanti.df)[1:(ncol(quanti.df)-1)] <- scale.vals
        quanti.plot <- reshape::melt(quanti.df,id.vars="CLUSTER")
        quanti.plot <- boxplot.quanti(quanti.plot)
        output.name <- paste0(output_folder,"/clus_",clus_num,"_num.jpg")
        set.size <- ncol(quanti.df) - 1
        ggsave(filename=output.name,quanti.plot,dpi = 300, width=5*set.size,height=30,units="cm",limitsize=F)
      }
    }
    #qualitative plots
    if(quali.act){
      quali.df <- ini.data[,!sapply(ini.data,is.numeric),drop=F]
      quali.df$CLUSTER <- ini.data$CLUSTER
      #quali.df <- quali.df[!is.na(quali.df$CLUSTER),]
      quali.df <- quali.df[complete.cases(quali.df),]
      quali.plot <- reshape::melt(quali.df,id.vars = "CLUSTER")
      quali.plot <- hist.quali(quali.plot)
      output.name <- paste0(output_folder,"/clus_",clus_num,"_cat.jpg")
      set.size <- sum(c(floor((ncol(quali.df)-1)/4),(ncol(quali.df)-1) %% 4))
      ggsave(filename=output.name,quali.plot,dpi = 300, width=40,height=10*set.size,units="cm",limitsize=F)
    }
  }
  #NA removal
  if(any(is.na(ini.data$CLUSTER))){
    warning(paste0(table(is.na(ini.data$CLUSTER))[2]," observations were incomplete and clustering was ommited"))
  }

  #### SAVE SUMMARY ####

  #merge
  report.data <- list(QUANTI_VARS=quanti.report,QUALI_VARS=quali.report,SHP=ini.shp)
  #save reports
  output.name <- paste0(output_folder,"/clus_",clus_num,"_repo.rds")
  saveRDS(report.data,output.name)
  print("****CLUSrepo end sucessfully*****")
  return(report.data)
}




