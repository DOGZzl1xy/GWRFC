#'@title Local variables importance (LVI) clustering from GWRFC outputs
#'@description This function summarize results from the GWRFC algorithm, clustering its main outputs (i.e. LVI) and using these results to report a summary based on its data source (i.e. the input_shapefile). It is also possible to use any other specific variable (e.g. probabilities of a target class) to generate reports but in ths case clustering is not applied and the variable is subset in quantiles (if numerical) or by classes (if categorical) to generate the report.
#'@param input_shapefile string or Spatial-class. Input shapefile with dependent and independent variables. It can be the filename of the shapefile or an object of class SpatialPolygonsDataFrame or SpatialPointsDataFrame.
#'@param input_GWRFC string or Spatial-class. Input shapefile of GWRFC outputs. It can be the filename of the shapefile or an object of class SpatialPolygonsDataFrame or SpatialPointsDataFrame.
#'@param method_hc string. A method to use for hierarchical clustering with hclust. It can be:"ward.D","ward.D2","single","complete","average","mcquitty","median", "centroid" or "SOM". The latter, is calculated with the kohonen library.
#'@param clus_data string. Data which should be used in clustering. It can be "LVI" to refer to all LVI variables used during GWRFC. Other specific column at input_GWRFC can be also used. In this case, hierarchical clustering is not applied and target variable is reclassified into quantiles if data is numerical, otherwise input is converted to factor and its levels used for report.
#'@param clus_num numeric or string. If applies hierarchical clustering, then it is the number of clusters. If it is defined as 'auto' (default), it is automatically calculated applying Calinski-Harabasz Index.
#'@param plots logical. If true, plots are generated and stored in the output_folder.
#'@param output_folder string. Output folder where LVIclust outputs will be stored.
#'@return The output of this function is a shapefile with the resulting clusters, a summary for each cluster stored in a .rds file, and optionally a series of plots to visualize the report.
#'@examples
#'#based in the example showed with the execution of GWRFC
#'list.files("C:/DATA/demo/deforestation",full.names=T,pattern=".shp") #get the output filename from GWRFC function
#'
#'LVIclust(input_shapefile = deforestation, #should be the same shapefile used to apply GWRFC (do not need to remove variables)
#'          input_GWRFC = "C:/DATA/demo/deforestation/GWRFC_ADP_400_exponential.shp", #filename of the GWRFC output
#'          method_hc="ward.D2", #hierarchical clustering is applied but see: help(hclust) for other methods.
#'          clus_data="LVI", #here is clustered all LVI results (34 in total, i.e. the number of variables used in the analysis).
#'          clus_num = 2, #number of clusters. It can be automatically calculated if it is 'auto'
#'          plots=T, #three plots referring to: LVI ranking by clusters, report for categorial and quantitative variables by cluster.
#'          output_folder = "C:/DATA/demo/deforestation") #check this folder for outputs generated by the function.
#'@export

LVIclust <- function(
  input_shapefile,
  input_GWRFC,
  method_hc="ward.D2",
  clus_data="LVI",
  clus_num="auto",
  plots=T,
  output_folder
){

  ##### PREPARE DATA #####

  print("Reading data...")

  #random + test
  set.seed(666)
  if(clus_num==1){
    stop("LVI Clustering can´t be less than 2")
  }
  #folder
  dir.create(output_folder,showWarnings = F, recursive = T)
  #read GWRFC
  if(class(input_GWRFC)=="SpatialPolygonsDataFrame"|class(input_GWRFC)=="SpatialPointsDataFrame"){
    gwrfc.shp <- input_GWRFC
    na.gwrfc <- complete.cases(gwrfc.shp@data)
    gwrfc.shp <- gwrfc.shp[na.gwrfc,]
  }else{
    gwrfc.shp <- shapefile(input_GWRFC)
    na.gwrfc <- complete.cases(gwrfc.shp@data)
    gwrfc.shp <- gwrfc.shp[na.gwrfc,]
  }
  #read RAW + filter rows
  if(class(input_shapefile)=="SpatialPolygonsDataFrame"|class(input_shapefile)=="SpatialPointsDataFrame"){
    raw.data <- input_shapefile@data
  }else{
    raw.data <- read.dbf(gsub(".shp$",".dbf",input_shapefile))
  }
  rownames(raw.data) <- 1:nrow(raw.data)
  raw.data <- raw.data[rownames(raw.data) %in% gwrfc.shp@data$ID_row,]
  gwrfc.shp@data$ID_row <- NULL
  #get LVI & model results + filter columns in RAW
  target.names <- names(gwrfc.shp@data)[grep("P_",names(gwrfc.shp@data))]
  target.names  <- c("BEST","DEP","PRED",target.names,"FAIL","KAPPA")
  gwrfc.dep <- gwrfc.shp@data[,which(names(gwrfc.shp@data) %in% target.names)]
  if(clus_data != "LVI"){
    if(!any(names(gwrfc.dep) %in% clus_data)){
      stop("clus_data not found")
    }
  }
  gwrfc.shp@data <- gwrfc.shp@data[,which(!names(gwrfc.shp@data) %in% target.names)]
  raw.data <- raw.data[,which(names(raw.data) %in% names(gwrfc.shp@data))]

  #### FUNCTIONS ####

  ApplyQuintiles <- function(x) {
    cut(x, breaks=c(quantile(df$orders, probs = seq(0, 1, by = 0.20))),
        labels=c("0-20","20-40","40-60","60-80","80-100"), include.lowest=TRUE)
  }

  bar.lvi <- function(x){
    #plot
    p <- ggplot(x, aes(x=reorder(variable, value),y=value,
                       group=CLUSTER,
                       fill=CLUSTER)) +
      theme_bw() +
      theme(plot.title = element_text(size = 20),
            #panel
            panel.grid.major = element_line(size = 0.5, linetype = 'dotted',colour = "black"),
            #legend
            legend.title=element_text(size=15),
            legend.text=element_text(size=15),
            legend.key = element_rect(colour = "black"),
            legend.position="bottom",
            #axis x
            axis.title.x=element_text(size=15),
            axis.text.x=element_text(hjust = 1,size=15),
            #axis y
            axis.title.y=element_text(size=15),
            axis.text.y=element_text(hjust = 1,size=15),
            strip.text.y=element_text(size=15),
            #facet titles off
            strip.background = element_blank(),
            strip.text.x = element_blank(),
            #margins
            plot.margin=unit(c(0,0,0,0),"cm")) +
      #legend columns
      guides(col = guide_legend(nrow=1,byrow=T)) +
      #shapes
      geom_col(position = "dodge") +
      #other
      coord_flip() +
      facet_wrap(~CLUSTER,ncol=2) +
      labs(title="Average importance of independent variables, grouped by clusters",
           x="Variables",
           y="Average importance (%)")

    return(p)
  }

  boxplot.quanti <- function(x,y_range=c(-3,3)){
    p <- ggplot(x,aes(x=reorder(variable,value), y=value,
                      fill=CLUSTER,
                      group=interaction(variable,CLUSTER))) +
      theme_bw() +
      theme(plot.title = element_text(size = 20),
            #legend
            legend.title=element_text(size=15),
            legend.text=element_text(size=15),
            legend.key = element_rect(colour = "black"),
            legend.position="bottom",
            #x axis
            axis.title.x=element_text(size=15),
            axis.text.x=element_text(hjust = 1,size=15,angle=45),
            #y axis
            axis.title.y=element_text(size=15),
            axis.text.y=element_text(hjust = 1,size=15),
            strip.text.y=element_text(size=15),
            #facet titles off
            strip.background = element_blank(),
            strip.text.x = element_blank(),
            #margins
            plot.margin=unit(c(0,0,0,0),"cm")) +
      #boxplot geom
      geom_boxplot(position=position_dodge(width = 0.75),outlier.alpha=0.33,
                   show.legend = T) +
      #others
      geom_hline(yintercept=0,linetype="dotted",color="black",size=0.75) +
      coord_cartesian(ylim=y_range) +
      labs(title="Standarized values for quantitative variables, grouped by clusters",
           x="Variables (Mean ± SD)",
           y="Z-scores")
    return(p)
  }

  hist.quali <- function(x){
    p <- ggplot(x,aes(x=value,
                      fill=CLUSTER)) +
      theme_bw() +
      theme(plot.title = element_text(size = 20),
            #legend
            legend.title=element_text(size=15),
            legend.text=element_text(size=15),
            legend.key = element_rect(colour = "black"),
            legend.position="bottom",
            #x axis
            axis.title.x=element_text(size=15),
            axis.text.x=element_text(hjust = 1,size=15,angle=45),
            strip.text.x=element_text(size=15),
            #y axis
            axis.title.y=element_text(size=15),
            axis.text.y=element_text(hjust = 1,size=15),
            strip.text.y=element_text(size=15),
            #margins
            plot.margin=unit(c(0,0,0,0),"cm")) +
      #bar geom
      geom_bar(position = "dodge") +
      #other
      coord_flip() +
      facet_wrap(~variable,scales="free",ncol=4) +
      labs(title="Classes counts for qualitative variables, grouped by clusters",
           y="Count",
           x="Classes")
    return(p)
  }

  Mode <- function(x) {
    ux <- unique(x)
    ux[which.max(tabulate(match(x, ux)))]
  }

  x.summary <- function(x,fun){
    if(fun=="Mode"){
      x.agr <- stats::aggregate(x[,1:(ncol(x)-1),drop=F],
                                by = list(x$CLUSTER),
                                FUN = Mode)
    }else{
      x.agr <- stats::aggregate(x[,1:(ncol(x)-1),drop=F],
                                by = list(x$CLUSTER),
                                FUN = fun)
    }
    names(x.agr)[1] <- "CLUSTER"
    x.agr <- reshape::melt(x.agr,id.vars="CLUSTER")
    names(x.agr)[3] <- fun
    return(x.agr)
  }

  get.elbow <- function(x, y, threshold) {
    d1 <- diff(y) / diff(x) # first derivative
    d2 <- diff(d1) / diff(x[-1]) # second derivative
    indices <- which(abs(d2) > threshold)
    return(indices)
  }

  plot.SOM <- function(x){
    if(ncol(x)!=9){
      x.na <- 9-length(x)
      x.na <- lapply(x.na,function(y){
        y <- rep(NA,nrow(x))
      })
      x <- cbind(x,as.data.frame(x.na))
    }
    jpeg(output.name, width = 1000, height = 1000)
    par(mfrow=c(3,3))
    for(j in 1:9){
      if(all(is.na(x[,j]))){
        plot(0,type='n',axes=FALSE,ann=FALSE)
      }else{
        plot(som_model,
             type = "property",
             property=x[,j],
             main=names(x)[j],
        )
      }
    }
    dev.off()
  }

  #### CLUSTERING ####

  print("Start clustering...")

  if(clus_data=="LVI"){

    # GET CLUSTER NUMBER

    if(clus_num=="auto"){
      gwrfc.clus <- hclust(dist(gwrfc.shp@data), method = "ward.D2")
      cal.vals <- list()
      for(i in 2:20){
        cal.vals[[i]] <- calinhara(gwrfc.shp@data,cutree(gwrfc.clus, k = i))
      }
      clus_num <- get.elbow(unlist(cal.vals),1:19,0.015)[1]
      if(is.na(clus_num)){
        warning("elbow not found. Assumed 2 clusters...")
        clus_num <- 2
      }
    }

    # REPORT WITH SOM

    if(method_hc=="SOM"){

      #apply SOM
      som_grid <- somgrid(xdim = 5, ydim=5, topo="hexagonal")
      som.data <- as.matrix(scale(gwrfc.shp@data))
      som_model <- som(som.data, grid = som_grid)
      som_cluster <- cutree(hclust(dist(unlist(som_model$codes))),k=clus_num)

      #plot SOM quality
      if(plots){
        som.plots <- c("codes", "changes", "counts","dist.neighbours", "mapping", "quality")
        output.name <- paste0(output_folder,"/",clus_data,"_",clus_num,"SOM_quality.jpg")
        jpeg(output.name, width = 1000, height = 1000)
        par(mfrow=c(3,3))
        for(j in 1:7){
          if(j!=7){
            plot(som_model, type=som.plots[j])
          }else{
            plot(som_model,
                 type = "property",
                 property=som_cluster,
                 main="clusters")
          }
        }
        dev.off()
        #plot LVI
        som.plots <- names(gwrfc.shp@data)
        som.plots <- split(som.plots, ceiling(seq_along(som.plots)/9))
        for(j in 1:length(som.plots)){
          output.name <- paste0(output_folder,"/",clus_data,"_",clus_num,"SOM_variables",j,".jpg")
          if(length(som.plots[[j]])==9){
            plot.SOM(gwrfc.shp@data[,som.plots[[j]]])
          }
        }
      }
      #assign CLUSTER
      gwrfc.shp@data$CLUSTER <- som_cluster[som_model$unit.classif]
    }else{

      # REPORT WITH HIERARCHICAL

      #get recommended clusters
      gwrfc.clus <- hclust(dist(gwrfc.shp@data), method = method_hc)
      #add data to LVI
      gwrfc.shp@data$CLUSTER <- cutree(gwrfc.clus, k = clus_num)

    }

  }else{

    # REPORT ISOLATING VARIABLE

    gwrfc.shp@data$CLUSTER <- gwrfc.dep[,grep(clus_data,names(gwrfc.dep))]
    if(class(gwrfc.shp@data$CLUSTER)!="factor"|class(gwrfc.shp@data$CLUSTER)!="character"){
      breaks.val <- gwrfc.shp@data$CLUSTER
      breaks.val <- c(-Inf,summary(breaks.val)[2],summary(breaks.val)[3],summary(breaks.val)[5],Inf)
      labels.val <- c("Q25","Q50","Q75","Q100")
      gwrfc.shp@data$CLUSTER <- base::cut(as.numeric(gwrfc.shp@data$CLUSTER),breaks=breaks.val,labels=labels.val)
    }else{
      gwrfc.shp@data$CLUSTER <- factor(gwrfc.shp@data$CLUSTER)
    }
    clus_num <- nlevels(gwrfc.shp@data$CLUSTER)
  }
  #output file
  cluster.shp <- gwrfc.shp
  cluster.shp@data <- data.frame(CLUSTER=gwrfc.shp@data$CLUSTER)
  output.name <- paste0(output_folder,"/",clus_data,"_",clus_num,"clus.shp")
  shapefile(cluster.shp,output.name,overwrite=T)

  #### LVI DATA REPORT ####

  print("Making report...")

  #get LVI data
  lvi.data <- gwrfc.shp@data
  lvi.data$CLUSTER <- factor(lvi.data$CLUSTER)
  #lvi values by cluster
  lvi.report <- x.summary(lvi.data,"mean")
  names(lvi.report)[3] <- "mean"
  lvi.report$sd <- x.summary(lvi.data,"sd")[,3]
  lvi.report$min <- x.summary(lvi.data,"min")[,3]
  lvi.report$max <- x.summary(lvi.data,"max")[,3]
  #bar plot
  if(plots){
    lvi.plot <- reshape::melt(lvi.data,id.vars="CLUSTER")
    lvi.plot <- bar.lvi(lvi.plot)
    output.name <- paste0(output_folder,"/",clus_data,"_",clus_num,"clus_LVIPlot.jpg")
    set.size <- sum(c(floor(clus_num/2),clus_num %% 2))
    ggsave(filename=output.name,lvi.plot,dpi = 300, width=25,height=10*clus_num,units="cm")
  }

  #### RAW DATA REPORT ####

  #get RAW data
  raw.data$DEP <- factor(gwrfc.dep$DEP)
  raw.data$CLUSTER <- factor(gwrfc.shp@data$CLUSTER)
  raw.type <- sapply(raw.data,class)
  #QUANTI variables by cluster
  quanti.df <- raw.data[,raw.type %in% "numeric",drop=F]
  quanti.df$CLUSTER <- raw.data$CLUSTER
  quanti.report <- x.summary(quanti.df,"mean")
  quanti.report$sd <- x.summary(quanti.df,"sd")[,3]
  quanti.report$min <- x.summary(quanti.df,"min")[,3]
  quanti.report$max <- x.summary(quanti.df,"max")[,3]
  #QUALI variables by cluster
  quali.df <- raw.data[,raw.type %in% c("factor","character"),drop=F]
  quanti.df$CLUSTER <- raw.data$CLUSTER
  quali.report <- x.summary(quali.df,"Mode")
  #plots
  if(plots){
    #for quantitative
    scale.vals <- scale(quanti.df[,1:(ncol(quanti.df)-1)])
    quanti.df[,1:(ncol(quanti.df)-1)] <- scale.vals
    scale.vals <- paste0(names(quanti.df)[1:(ncol(quanti.df)-1)],"\n","(",
                         round(attr(scale.vals,"scaled:center"),2)," ± ",
                         round(attr(scale.vals,"scaled:scale"),2),")")
    names(quanti.df)[1:(ncol(quanti.df)-1)] <- scale.vals
    quanti.plot <- reshape::melt(quanti.df,id.vars="CLUSTER")
    quanti.plot <- boxplot.quanti(quanti.plot)
    output.name <- paste0(output_folder,"/",clus_data,"_",clus_num,"clus_quantiPlot.jpg")
    set.size <- ncol(quanti.df) - 1
    ggsave(filename=output.name,quanti.plot,dpi = 300, width=5*set.size,height=30,units="cm",limitsize=F)
    #for qualitative
    quali.plot <- reshape::melt(quali.df,id.vars = "CLUSTER")
    quali.plot <- hist.quali(quali.plot)
    output.name <- paste0(output_folder,"/",clus_data,"_",clus_num,"clus_qualiPlot.jpg")
    set.size <- sum(c(floor((ncol(quali.df)-1)/4),(ncol(quali.df)-1) %% 4))
    ggsave(filename=output.name,quali.plot,dpi = 300, width=40,height=10*set.size,units="cm",limitsize=F)
  }
  #get accuracy data
  acc.data <- gwrfc.dep
  acc.data$CLUSTER <- raw.data$CLUSTER
  acc.data <- acc.data[,names(acc.data) %in% c("KAPPA","CLUSTER")]
  acc.report <- x.summary(acc.data,"mean")
  acc.report$sd <- x.summary(acc.data,"sd")[,3]
  acc.report$min <- x.summary(acc.data,"min")[,3]
  acc.report$max <- x.summary(acc.data,"max")[,3]
  #get probabilities data
  prob.data <- gwrfc.dep
  prob.data$CLUSTER <- raw.data$CLUSTER
  prob.data <- prob.data[,names(prob.data) %in% c(grep("^P_",names(prob.data),value=T),"CLUSTER")]
  prob.report <- x.summary(prob.data,"mean")
  prob.report$sd <- x.summary(prob.data,"sd")[,3]
  prob.report$min <- x.summary(prob.data,"min")[,3]
  prob.report$max <- x.summary(prob.data,"max")[,3]

  #### PRESENT REPORTS ####

  #merge
  report.data <- list(ACCURACY=acc.report,
                      PROBABILITIES=prob.report,
                      QUANTI_VARS=quanti.report,
                      QUALI_VARS=quali.report,
                      LVI=lvi.report)
  #save reports
  output.name <- paste0(output_folder,"/",clus_data,"_",clus_num,"clus_report.rds")
  saveRDS(report.data,output.name)
  print("****LVIclust end sucessfully*****")
  return(report.data)
}




